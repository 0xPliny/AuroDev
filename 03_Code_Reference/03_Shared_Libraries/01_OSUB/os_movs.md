# os_movs - MHC_MOVS Table Operations

**Document Version:** 1.0  
**Last Updated:** 2024-12-23  
**Author:** CmL  
**Confidence Score:** 0.95

---

## Document Metadata

| Field | Value |
|-------|-------|
| **Source File** | `os_movs.cpp`, `os_movs.h` |
| **Generated From** | `MHC_MOVS` table definition in `database_tables.xml` |
| **Location** | `D:\ICIS\AuroDev\clogan\AuroDev\MSVC Programs\osub\` |
| **Table Name** | `MHC_MOVS` |
| **Primary Key** | `loadid`, `area` (composite) |
| **Generated By** | `p_ut_makdb` utility |
| **Status** | âœ… Generated - DO NOT MODIFY |

---

## Overview

The `MHC_MOVS` table is the **core move record table** in the MHC system. Every load movement through the system is tracked via a MOVS record. This table is accessed more frequently than any other table in the system.

**Critical Operations:**
- Move creation (insert)
- Move state transitions (update)
- Move querying (select)
- Move history tracking

---

## Table Structure

```cpp
typedef struct movs
{
    // Audit Fields
    char    modify_user[132+1];          // User who last modified record
    char    history_func[50+1];          // Function that created history entry
    char    history_comment[256+1];      // History comment text
    char    add_date[24+1];              // Date record was added
    char    add_user[132+1];             // User who added record
    char    modify_date[24+1];           // Date record was last modified
    
    // Primary Key Fields
    char    loadid[6+1];                 // Load ID (part of primary key)
    char    area[1+1];                   // System area (part of primary key)
    
    // Move Status Fields
    char    move_status[20+1];           // Current move status (PEND, ACTV, COMP, etc.)
    char    move_current_action[20+1];   // Current action being performed
    char    route_status[15+1];         // Routing status
    
    // Station Fields
    char    initial_station[20+1];      // Starting station
    char    current_station[20+1];      // Current station
    char    next_station[20+1];         // Next station in route
    char    final_station[20+1];        // Final destination station
    
    // Location Fields
    char    initial_location[20+1];     // Starting location
    char    final_location[20+1];       // Final destination location
    
    // Move Type Fields
    char    move_type[20+1];            // Move type (STOR, RTRV, MOVE, etc.)
    char    move_sub_type[20+1];        // Move sub-type
    char    load_type[20+1];            // Load type
    
    // Aisle/Zone Fields
    long    aisle;                      // Aisle number
    long    mandatory_aisle;            // Required aisle (if any)
    char    storage_zone[15+1];         // Storage zone
    char    source[15+1];               // Source identifier
    
    // Scheduling Fields
    char    release_date[24+1];          // When move can be released
    char    scheduled_date[24+1];       // Scheduled execution date
    long    scheduled_count;            // Scheduled count
    long    priority;                   // Move priority
    
    // Equipment Fields
    long    fork_number;                // Fork number (for multi-fork stackers)
    char    vehicle_name[20+1];         // Vehicle assigned to move
    long    load_size;                  // Load size
    
    // Move Tracking Fields
    char    move_id[20+1];              // Unique move ID
    long    sequence_no;               // Sequence number
    char    move_start_date[24+1];     // When move actually started
    char    reroute[3+1];              // Reroute flag (YES/NO)
    char    exercise[3+1];             // Exercise move flag (YES/NO)
    
    // Error Fields
    long    error_code;                // Error code
    long    reason_code;               // Reason code
    char    error_reason[100+1];       // Error reason text
    
    // Special Flags
    long    shuffle_flag;              // Shuffle move flag
    
    // History Fields
    char    history_catagory[50+1];    // History category
    long    history_level;              // History level
    long    history_onoff;              // History on/off flag
    long    history_sequence_no;        // History sequence number
    
    // Internal Fields
    char    MOVS_dum[2];               // Dummy field (alignment)
    _RecordsetPtr    RsP;              // ADO Recordset pointer (internal use)
} MOVS;
```

---

## Primary Key

| Field(s) | Type | Description |
|----------|------|-------------|
| `loadid` | `char[7]` | Load identifier |
| `area` | `char[2]` | System area (typically "A") |

**Note:** The composite primary key allows multiple moves for the same load in different areas (rare but possible).

---

## Generated Functions

### MOVS_select_MOVS_PR_KEY

**Signature:**
```cpp
long MOVS_select_MOVS_PR_KEY(MOVS *sel, GP_BOOL Update);
```

**Description:**
Selects a single MOVS record by primary key (`loadid` and `area`). This is the most common way to retrieve a specific move record.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure. Must have `loadid` and `area` set before calling.
- `Update` (GP_BOOL): 
  - `GP_TRUE`: Lock record for update (pessimistic lock)
  - `GP_FALSE`: Read-only access

**Return Values:**
- `GP.GOOD` (0): Record found and loaded
- `GP.UGLY` (-2): Record not found
- `GP.DBHELD` (-1): Record locked by another process
- Other: Database error

**Logic Flow:**
1. Creates ADO Recordset if needed
2. Closes existing recordset if open
3. Builds SQL: `SELECT * FROM MHC_MOVS WHERE loadid = '{loadid}' AND area = '{area}'`
4. Sets lock type based on `Update` parameter
5. Opens recordset
6. Moves to first record
7. Copies all fields from database to structure
8. Converts date fields from database format to internal format

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

if (MOVS_select_MOVS_PR_KEY(&movs, GP_FALSE) == GP.GOOD) {
    // Use movs data
    cs_log_printf(FILELINE, 3, "Move status: %s", movs.move_status);
} else {
    // Record not found or error
}
```

**Locking Behavior:**
- If `Update = GP_TRUE`: Record is locked with `adLockPessimistic`
- If transaction is active (`BeginTrans_Level > 0`): Always uses pessimistic lock
- Lock is held until recordset is closed or transaction commits/rolls back

---

### MOVS_select_LOOP

**Signature:**
```cpp
long MOVS_select_LOOP(MOVS *sel, long *count, char *where, GP_BOOL Update, int top = 0);
```

**Description:**
Selects multiple MOVS records using a WHERE clause. Designed for iteration through result sets. Supports TOP clause for limiting results.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure
- `count` (long*): 
  - First call: Set to 0
  - Subsequent calls: Pass same pointer (function increments)
  - Close cursor: Set to -1
- `where` (char*): SQL WHERE clause (without "WHERE" keyword)
- `Update` (GP_BOOL): Lock type
- `top` (int): Optional. Limit number of records (0 = no limit)

**Return Values:**
- `GP.GOOD` (0): Record retrieved
- `GP.UGLY` (-2): No more records (EOF)
- `GP.DBHELD` (-1): Record locked
- Other: Database error

**Logic Flow:**
1. **First Call (`count == 0`):**
   - Creates recordset
   - Builds SQL: `SELECT [TOP n] * FROM MHC_MOVS [WITH (ReadUncommitted)] WHERE {where}`
   - Opens recordset
   - Moves to first record
   - Copies data to structure
   - Increments count

2. **Subsequent Calls:**
   - Moves to next record (`MoveNext()`)
   - Copies data to structure
   - Increments count

3. **Close (`count == -1`):**
   - Closes recordset
   - Returns `GP.GOOD`

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
long count = 0;
char where[256];
sprintf(where, "move_status = 'PEND' AND area = 'A'");

// Iterate through all pending moves
while (MOVS_select_LOOP(&movs, &count, where, GP_FALSE, 0) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Processing move: %s, status: %s", 
                  movs.loadid, movs.move_status);
    // Process move
}

// Close cursor
count = -1;
MOVS_select_LOOP(&movs, &count, "", GP_FALSE, 0);
```

**Performance Notes:**
- Uses `WITH (ReadUncommitted)` for read-only queries (dirty reads allowed)
- Uses `TOP` clause when specified to limit result set size
- Forward-only cursor for performance

---

### MOVS_select_LOOP_2

**Signature:**
```cpp
long MOVS_select_LOOP_2(MOVS *sel, long *count, char *where, char Update);
```

**Description:**
Alternative loop function with `char` Update parameter instead of `GP_BOOL`. Functionally identical to `MOVS_select_LOOP`.

**Note:** Prefer `MOVS_select_LOOP` for new code.

---

### MOVS_insert

**Signature:**
```cpp
long MOVS_insert(MOVS *sel, ...);
```

**Description:**
Inserts a new MOVS record into the database. All required fields must be set before calling.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure with data to insert
- `...`: Variable arguments (not used in current implementation)

**Return Values:**
- `GP.GOOD` (0): Record inserted successfully
- `GP.BAD` (-1): Insert failed (duplicate key, constraint violation, etc.)
- Other: Database error

**Required Fields:**
- `loadid` (primary key)
- `area` (primary key)
- `move_status`
- `move_type`
- `add_date` (typically set automatically)
- `add_user` (typically set automatically)

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);

// Set primary key
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

// Set required fields
cc_str.copy(movs.move_status, sizeof(movs.move_status), "PEND");
cc_str.copy(movs.move_type, sizeof(movs.move_type), "STOR");
cc_str.copy(movs.initial_station, sizeof(movs.initial_station), "PD01");
cc_str.copy(movs.final_station, sizeof(movs.final_station), "SR01");

// Set audit fields
double curDate;
cs_dtm_current(&curDate);
cs_dtm_fmt(movs.add_date, sizeof(movs.add_date), curDate, DTM_MASK);
cc_str.copy(movs.add_user, sizeof(movs.add_user), gg.prgnam());

if (MOVS_insert(&movs) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Move inserted: %s", movs.loadid);
} else {
    cs_log_printf(FILELINE, 0, "Failed to insert move: %s", movs.loadid);
}
```

**Transaction Requirements:**
- Should be called within a transaction started with `SQL.start(SQL.READ_WRITE)`
- Commit with `SQL.commit()` after successful insert

---

### MOVS_update

**Signature:**
```cpp
long MOVS_update(MOVS *sel);
long MOVS_update(MOVS *sel, char* table);
```

**Description:**
Updates an existing MOVS record. Record must have been selected with `Update = GP_TRUE` or be within an active transaction.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure with modified data
- `table` (char*): Optional. Table name override (rarely used)

**Return Values:**
- `GP.GOOD` (0): Record updated successfully
- `GP.BAD` (-1): Update failed
- `GP.DBHELD` (-1): Record locked by another process
- Other: Database error

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

// Select with lock for update
if (MOVS_select_MOVS_PR_KEY(&movs, GP_TRUE) == GP.GOOD) {
    // Modify fields
    cc_str.copy(movs.move_status, sizeof(movs.move_status), "ACTV");
    cc_str.copy(movs.current_station, sizeof(movs.current_station), "SR01");
    
    // Update
    if (MOVS_update(&movs) == GP.GOOD) {
        cs_log_printf(FILELINE, 3, "Move updated: %s", movs.loadid);
    }
}
```

**Important Notes:**
- Record must be locked before update (select with `Update = GP_TRUE`)
- All fields are updated (not just changed fields)
- `modify_date` and `modify_user` should be updated before calling

---

### MOVS_update_where

**Signature:**
```cpp
long MOVS_update_where(MOVS *sel, char *strset, char *where);
```

**Description:**
Updates multiple MOVS records matching a WHERE clause. Uses SQL UPDATE statement directly.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure (used for connection, data not used)
- `strset` (char*): SQL SET clause (e.g., "move_status = 'COMP'")
- `where` (char*): SQL WHERE clause

**Return Values:**
- `GP.GOOD` (0): Update successful
- `GP.BAD` (-1): Update failed
- Other: Database error

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);

char set[256];
char where[256];
sprintf(set, "move_status = 'COMP', modify_date = GETDATE()");
sprintf(where, "move_status = 'ACTV' AND area = 'A'");

if (MOVS_update_where(&movs, set, where) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Bulk update completed");
}
```

**Warning:** This function updates records without locking them individually. Use with caution in multi-process environments.

---

### MOVS_delete

**Signature:**
```cpp
long MOVS_delete(MOVS *sel);
```

**Description:**
Deletes a single MOVS record. Record must be selected first.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure with primary key set

**Return Values:**
- `GP.GOOD` (0): Record deleted
- `GP.BAD` (-1): Delete failed
- Other: Database error

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

if (MOVS_select_MOVS_PR_KEY(&movs, GP_TRUE) == GP.GOOD) {
    if (MOVS_delete(&movs) == GP.GOOD) {
        cs_log_printf(FILELINE, 3, "Move deleted: %s", movs.loadid);
    }
}
```

**Note:** Deletion of MOVS records is rare. Typically moves are completed, not deleted.

---

### MOVS_delete_where

**Signature:**
```cpp
long MOVS_delete_where(MOVS *sel, char *where, char *top = NULL);
```

**Description:**
Deletes multiple MOVS records matching a WHERE clause.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure (used for connection)
- `where` (char*): SQL WHERE clause
- `top` (char*): Optional. TOP clause (e.g., "100")

**Warning:** Use with extreme caution. Bulk deletes can affect system integrity.

---

### MOVS_count

**Signature:**
```cpp
long MOVS_count(MOVS *sel, long* i_count, char *where);
long MOVS_count(MOVS *sel, long* i_count, char* what, char *where);
```

**Description:**
Counts MOVS records matching a WHERE clause.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure (used for connection)
- `i_count` (long*): Output - count result
- `where` (char*): SQL WHERE clause
- `what` (char*): Optional. COUNT expression (e.g., "DISTINCT loadid")

**Return Values:**
- `GP.GOOD` (0): Count successful
- `GP.BAD` (-1): Count failed

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
long count = 0;
char where[256];
sprintf(where, "move_status = 'PEND' AND area = 'A'");

if (MOVS_count(&movs, &count, where) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Pending moves: %ld", count);
}
```

---

### MOVS_sum

**Signature:**
```cpp
long MOVS_sum(MOVS *sel, long* i_count, char *sum, char *where);
```

**Description:**
Sums a numeric field for MOVS records matching a WHERE clause.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure
- `i_count` (long*): Output - sum result
- `sum` (char*): Field to sum (e.g., "priority")
- `where` (char*): SQL WHERE clause

**Usage Example:**
```cpp
MOVS movs;
MOVS_init(&movs);
long totalPriority = 0;
char where[256];
sprintf(where, "move_status = 'PEND'");

if (MOVS_sum(&movs, &totalPriority, "priority", where) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Total priority: %ld", totalPriority);
}
```

---

### MOVS_history

**Signature:**
```cpp
void MOVS_history(MOVS *sel, char* history_catagory, char* history_comment, 
                   char* history_func, long history_level);
void MOVS_history(MOVS *sel, char* history_catagory, char* history_comment, 
                  char* history_func, long history_level, long history_onoff);
```

**Description:**
Creates a history entry for the MOVS record. History is written to `MHC_MOVS_LOG` table.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure
- `history_catagory` (char*): History category (e.g., "STATUS_CHANGE")
- `history_comment` (char*): History comment text
- `history_func` (char*): Function name creating history
- `history_level` (long): History level (0-10)
- `history_onoff` (long): Optional. History on/off flag

**Usage Example:**
```cpp
MOVS movs;
// ... select and modify movs ...

MOVS_history(&movs, "STATUS_CHANGE", "Move activated", 
             "p_ar_movdp", 3);
```

---

### MOVS_init

**Signature:**
```cpp
void MOVS_init(MOVS *sel);
```

**Description:**
Initializes a MOVS structure to default values. **Always call this before using a MOVS structure.**

**Usage:**
```cpp
MOVS movs;
MOVS_init(&movs);  // Always initialize first
// Now safe to use movs
```

---

### MOVS_copy

**Signature:**
```cpp
void MOVS_copy(MOVS *to, MOVS *from);
void MOVS_copy(MOVS *to, MOVS *from, const bool with_RSP);
```

**Description:**
Copies one MOVS structure to another.

**Parameters:**
- `to` (MOVS*): Destination structure
- `from` (MOVS*): Source structure
- `with_RSP` (bool): Optional. Copy Recordset pointer (default: false)

---

### MOVS_get

**Signature:**
```cpp
char* MOVS_get(MOVS *sel, char* field, char* format, char* buffer, size_t sizeInBytes);
```

**Description:**
Gets a formatted field value from MOVS structure.

**Parameters:**
- `sel` (MOVS*): Pointer to MOVS structure
- `field` (char*): Field name
- `format` (char*): Format string
- `buffer` (char*): Output buffer
- `sizeInBytes` (size_t): Buffer size

---

## Static Class Wrapper: db_MOVS

The `db_MOVS` class provides an object-oriented wrapper around the C functions:

```cpp
static class db_MOVS {
public:
    long PR_KEY(MOVS *sel, GP_BOOL Update);
    long LOOP(MOVS *sel, long *count, char *where, GP_BOOL Update);
    long LOOP(MOVS *sel, long *count, char *where, GP_BOOL Update, int top);
    long LOOP_2(MOVS *sel, long *count, char *where, char Update);
    long delete_it(MOVS *sel);
    long delete_where(MOVS *sel, char *where);
    long delete_where(MOVS *sel, char *where, char *top);
    long update_where(MOVS *sel, char *strset, char *where);
    long update(MOVS *sel);
    long update(MOVS *sel, char* up_table);
    long insert(MOVS *sel);
    long count(MOVS *sel, long* i_count, char *where);
    long count(MOVS *sel, long* i_count, char* what, char *where);
    long sum(MOVS *sel, long* i_count, char *sum, char *where);
    void init(MOVS *sel);
    void history(MOVS *sel, char* cat, char* comment, char* func, long level);
    void history(MOVS *sel, char* cat, char* comment, char* func, long level, long onoff);
    void copy(MOVS *to, MOVS *from);
    void copy(MOVS *to, MOVS *from, const bool with_RSP);
    char* get(MOVS *sel, char* field, char* format, char* buffer, size_t sizeInBytes);
} MOVS_;
```

**Usage:**
```cpp
MOVS movs;
MOVS_.init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

if (MOVS_.PR_KEY(&movs, GP_FALSE) == GP.GOOD) {
    // Use movs
}
```

---

## Common Usage Patterns

### Pattern 1: Select Single Record

```cpp
MOVS movs;
MOVS_init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

if (MOVS_select_MOVS_PR_KEY(&movs, GP_FALSE) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Move %s: status=%s, type=%s", 
                  movs.loadid, movs.move_status, movs.move_type);
} else {
    cs_log_printf(FILELINE, 0, "Move not found: %s", movs.loadid);
}
```

### Pattern 2: Iterate Multiple Records

```cpp
MOVS movs;
MOVS_init(&movs);
long count = 0;
char where[256];
sprintf(where, "move_status = 'PEND' AND area = 'A' ORDER BY priority DESC");

while (MOVS_select_LOOP(&movs, &count, where, GP_FALSE, 0) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Processing move %s (priority %ld)", 
                  movs.loadid, movs.priority);
    // Process move
}

// Close cursor
count = -1;
MOVS_select_LOOP(&movs, &count, "", GP_FALSE, 0);
```

### Pattern 3: Insert New Record

```cpp
SQL.start(SQL.READ_WRITE);

MOVS movs;
MOVS_init(&movs);

// Set primary key
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

// Set required fields
cc_str.copy(movs.move_status, sizeof(movs.move_status), "PEND");
cc_str.copy(movs.move_type, sizeof(movs.move_type), "STOR");
cc_str.copy(movs.initial_station, sizeof(movs.initial_station), "PD01");
cc_str.copy(movs.final_station, sizeof(movs.final_station), "SR01");

// Set audit fields
double curDate;
cs_dtm_current(&curDate);
cs_dtm_fmt(movs.add_date, sizeof(movs.add_date), curDate, DTM_MASK);
cc_str.copy(movs.add_user, sizeof(movs.add_user), gg.prgnam());

if (MOVS_insert(&movs) == GP.GOOD) {
    SQL.commit();
    cs_log_printf(FILELINE, 3, "Move created: %s", movs.loadid);
} else {
    SQL.rollback();
    cs_log_printf(FILELINE, 0, "Failed to create move: %s", movs.loadid);
}
```

### Pattern 4: Update Existing Record

```cpp
SQL.start(SQL.READ_WRITE);

MOVS movs;
MOVS_init(&movs);
cc_str.copy(movs.loadid, sizeof(movs.loadid), "L00001");
cc_str.copy(movs.area, sizeof(movs.area), "A");

// Select with lock for update
if (MOVS_select_MOVS_PR_KEY(&movs, GP_TRUE) == GP.GOOD) {
    // Modify fields
    cc_str.copy(movs.move_status, sizeof(movs.move_status), "ACTV");
    cc_str.copy(movs.current_station, sizeof(movs.current_station), "SR01");
    
    // Update audit fields
    double curDate;
    cs_dtm_current(&curDate);
    cs_dtm_fmt(movs.modify_date, sizeof(movs.modify_date), curDate, DTM_MASK);
    cc_str.copy(movs.modify_user, sizeof(movs.modify_user), gg.prgnam());
    
    // Create history
    MOVS_history(&movs, "STATUS_CHANGE", "Move activated", 
                 gg.prgnam(), 3);
    
    if (MOVS_update(&movs) == GP.GOOD) {
        SQL.commit();
        cs_log_printf(FILELINE, 3, "Move updated: %s", movs.loadid);
    } else {
        SQL.rollback();
    }
} else {
    SQL.rollback();
    cs_log_printf(FILELINE, 0, "Move not found or locked: %s", movs.loadid);
}
```

---

## Related Tables

| Table | Relationship | Foreign Key |
|-------|--------------|-------------|
| `MHC_LOAD` | Parent | `MHC_LOAD.loadid = MHC_MOVS.loadid` |
| `MHC_LOCATION` | Destination | `MHC_LOCATION.location = MHC_MOVS.final_location` |
| `MHC_STTN` | Station | `MHC_STTN.station = MHC_MOVS.current_station` |
| `MHC_MOVS_LOG` | History | `MHC_MOVS_LOG.loadid = MHC_MOVS.loadid` |

---

## Move Status Values

Common move status values (see `ICISDefines.vb` or `global_prm.h`):

| Status | Constant | Description |
|--------|----------|-------------|
| `PEND` | `GP.MOVS.STATUS.PEND()` | Pending - waiting to be processed |
| `ACTV` | `GP.MOVS.STATUS.ACTV()` | Active - currently being processed |
| `COMP` | `GP.MOVS.STATUS.COMP()` | Complete - move finished |
| `CANC` | `GP.MOVS.STATUS.CANC()` | Cancelled - move cancelled |
| `HELD` | `GP.MOVS.STATUS.HELD()` | Held - move on hold |

---

## Move Type Values

| Type | Description |
|------|-------------|
| `STOR` | Store - put load into storage |
| `RTRV` | Retrieve - get load from storage |
| `MOVE` | Move - transfer between locations |
| `SHUF` | Shuffle - reorganize storage |

---

## Cross-References

| Topic | Document | Section |
|-------|----------|---------|
| Database Schema | [MHC_MOVS Schema](../../04_Database_Reference/01_Core_Tables/MHC_MOVS.md) | Table Definition |
| Move Dispatcher | [p_ar_movdp](../01_Background_Processes/p_ar_movdp.md) | Uses MOVS |
| Stacker Dispatcher | [p_ar_stkdp](../01_Background_Processes/p_ar_stkdp.md) | Uses MOVS |
| Move Workflow | [Inbound Move](../../05_Workflows/01_Inbound_Move.md) | MOVS Creation |
| DSUB Move Ops | [DSUB Library](../dsub.md) | ds_movs_* functions |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-12-23 | Initial comprehensive documentation |

