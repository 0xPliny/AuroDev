# os_route - MHC_ROUTE Table Operations

**Document Version:** 1.0  
**Last Updated:** 2024-12-23  
**Author:** CmL  
**Confidence Score:** 0.95

---

## Document Metadata

| Field | Value |
|-------|-------|
| **Source File** | `os_route.cpp`, `os_route.h` |
| **Generated From** | `MHC_ROUTE` table definition in `database_tables.xml` |
| **Location** | `D:\ICIS\AuroDev\clogan\AuroDev\MSVC Programs\osub\` |
| **Table Name** | `MHC_ROUTE` |
| **Primary Key** | `current_station`, `final_station`, `next_station`, `area`, `sequence_no` (composite) |
| **Generated By** | `p_ut_makdb` utility |
| **Status** | ✅ Generated - DO NOT MODIFY |

---

## Overview

The `MHC_ROUTE` table defines **routing paths** between stations. Each route record specifies a path segment (current → next → final) with cost, status checks, and routing logic.

**Critical Operations:**
- Route definition and lookup
- Cost calculation
- Station status checking
- Path selection

**Note:** This is a complex table with many conditional fields for route validation.

---

## Table Structure

```cpp
typedef struct route
{
    // Primary Key Fields
    char    current_station[20+1];       // Current station
    char    final_station[20+1];         // Final station
    char    next_station[20+1];          // Next station
    char    area[1+1];                   // System area
    long    sequence_no;                 // Sequence number
    
    // Route Information Fields
    char    current_action[15+1];        // Current action
    char    move_status[15+1];           // Move status
    char    location_type[20+1];         // Location type
    char    move_type[20+1];             // Move type
    
    // Cost Fields
    long    current_cost;                 // Current segment cost
    long    base_cost;                    // Base cost
    long    rate_busy;                    // Rate when busy
    long    rate_off;                     // Rate when offline
    
    // Control Fields
    char    reset_status[10+1];          // Reset status
    char    send_move[3+1];              // Send move flag (YES/NO)
    char    reroute[3+1];                // Reroute flag (YES/NO)
    char    primary_path[3+1];           // Primary path flag
    char    skip_path[3+1];              // Skip path flag
    char    test_path[3+1];              // Test path flag
    char    test_seg[3+1];                // Test segment flag
    long    sync_flag;                    // Synchronization flag
    long    display_seq;                  // Display sequence
    
    // Current Station Check Fields
    char    current_bit_check[3+1];      // Bit check flag
    char    current_enroute[3+1];        // Enroute check flag
    char    current_loaded[3+1];         // Loaded check flag
    char    current_mode[3+1];           // Mode check flag
    long    current_mode_value;           // Mode value to check
    char    current_hard[4+1];           // Hardware check
    char    current_soft[4+1];           // Software check
    char    current_test[3+1];           // Test check flag
    char    current_available[3+1];       // Available check flag
    long    current_ignore0;             // Ignore flags (0-9)
    long    current_ignore1;
    long    current_ignore2;
    long    current_ignore3;
    long    current_ignore4;
    long    current_ignore5;
    long    current_ignore6;
    long    current_ignore7;
    long    current_ignore8;
    long    current_ignore9;
    
    // Next Station Check Fields (same structure as current)
    char    next_bit_check[3+1];
    char    next_enroute[3+1];
    char    next_loaded[3+1];
    char    next_mode[3+1];
    long    next_mode_value;
    char    next_hard[4+1];
    char    next_soft[4+1];
    char    next_test[3+1];
    char    next_available[3+1];
    long    next_ignore0;
    long    next_ignore1;
    long    next_ignore2;
    long    next_ignore3;
    long    next_ignore4;
    long    next_ignore5;
    long    next_ignore6;
    long    next_ignore7;
    long    next_ignore8;
    long    next_ignore9;
    
    // Final Station Check Fields (same structure as current)
    char    final_bit_check[3+1];
    char    final_enroute[3+1];
    char    final_loaded[3+1];
    char    final_mode[3+1];
    long    final_mode_value;
    char    final_hard[4+1];
    char    final_soft[4+1];
    char    final_req_load[3+1];
    char    final_test[3+1];
    char    final_available[3+1];
    long    final_ignore0;
    long    final_ignore1;
    long    final_ignore2;
    long    final_ignore3;
    long    final_ignore4;
    long    final_ignore5;
    long    final_ignore6;
    long    final_ignore7;
    long    final_ignore8;
    long    final_ignore9;
    
    // Additional Fields
    char    check_for_ok_agv[3+1];       // Check for OK AGV flag
    long    level_no;                     // Level number
    
    // Audit Fields
    char    add_date[24+1];              // Date record was added
    char    add_user[132+1];             // User who added record
    char    modify_date[24+1];           // Date record was last modified
    char    modify_user[132+1];          // User who last modified record
    
    // Internal Fields
    _RecordsetPtr    RsP;                // ADO Recordset pointer (internal use)
} ROUTE;
```

---

## Primary Key

| Field(s) | Type | Description |
|----------|------|-------------|
| `current_station` | `char[21]` | Current station |
| `final_station` | `char[21]` | Final destination station |
| `next_station` | `char[21]` | Next station in path |
| `area` | `char[2]` | System area |
| `sequence_no` | `long` | Sequence number |

---

## Generated Functions

### ROUTE_select_ROUTE_PR_KEY

**Signature:**
```cpp
long ROUTE_select_ROUTE_PR_KEY(ROUTE *sel, GP_BOOL Update);
```

**Description:**
Selects a single ROUTE record by primary key.

**SQL Generated:**
```sql
SELECT * FROM MHC_ROUTE WHERE current_station = '{current_station}' 
  AND final_station = '{final_station}' 
  AND next_station = '{next_station}' 
  AND area = '{area}' 
  AND sequence_no = {sequence_no}
```

---

### ROUTE_select_LOOP

**Signature:**
```cpp
long ROUTE_select_LOOP(ROUTE *sel, long *count, char *where, GP_BOOL Update, int top = 0);
```

**Description:**
Selects multiple ROUTE records using a WHERE clause. Commonly used to find all routes from a current station to a final station.

**Usage Example:**
```cpp
ROUTE route;
ROUTE_init(&route);
long count = 0;
char where[256];
sprintf(where, "current_station = 'PD01' AND final_station = 'PD02' AND area = 'A' ORDER BY current_cost");

// Get all routes from PD01 to PD02, sorted by cost
while (ROUTE_select_LOOP(&route, &count, where, GP_FALSE, 0) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Route: %s -> %s -> %s, cost=%ld", 
                  route.current_station, route.next_station, route.final_station, route.current_cost);
}

count = -1;
ROUTE_select_LOOP(&route, &count, "", GP_FALSE, 0);
```

---

## Related Tables

| Table | Relationship | Foreign Key |
|-------|--------------|-------------|
| `MHC_STTN` | Reference | `MHC_ROUTE.current_station = MHC_STTN.station` |
| `MHC_STTN` | Reference | `MHC_ROUTE.next_station = MHC_STTN.station` |
| `MHC_STTN` | Reference | `MHC_ROUTE.final_station = MHC_STTN.station` |

---

## Cross-References

| Topic | Document | Section |
|-------|----------|---------|
| Station Operations | [os_sttn.md](os_sttn.md) | STTN used in routes |
| Routing Logic | [DSUB Library](../dsub.md) | ds_route functions |
| Move Routing | [p_ar_movdp](../01_Background_Processes/p_ar_movdp.md) | Uses ROUTE |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-12-23 | Initial comprehensive documentation |

