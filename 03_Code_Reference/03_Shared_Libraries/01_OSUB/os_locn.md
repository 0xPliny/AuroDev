# os_locn - MHC_LOCATION Table Operations

**Document Version:** 1.0  
**Last Updated:** 2024-12-23  
**Author:** CmL  
**Confidence Score:** 0.95

---

## Document Metadata

| Field | Value |
|-------|-------|
| **Source File** | `os_locn.cpp`, `os_locn.h` |
| **Generated From** | `MHC_LOCATION` table definition in `database_tables.xml` |
| **Location** | `D:\ICIS\AuroDev\clogan\AuroDev\MSVC Programs\osub\` |
| **Table Name** | `MHC_LOCATION` |
| **Primary Key** | `location` |
| **Generated By** | `p_ut_makdb` utility |
| **Status** | ✅ Generated - DO NOT MODIFY |

---

## Overview

The `MHC_LOCATION` table defines **all storage locations** in the warehouse system. Each physical storage position (rack bay, level, deep position) has a corresponding LOCN record that tracks its status, capacity, and current contents.

**Critical Operations:**
- Location availability checking
- Location status management
- Location locking/unlocking
- Location search and selection

**Key Concepts:**
- **Location Status:** AVAIL (available), OCCUPIED (has load), LOCKED (locked out)
- **Pending Status:** Tracks loads that are about to be stored/retrieved
- **Double-Deep:** Locations can have near/far partner locations

---

## Table Structure

```cpp
typedef struct locn
{
    // Audit Fields
    char    modify_user[132+1];          // User who last modified record
    char    history_func[50+1];          // Function that created history entry
    char    history_comment[256+1];      // History comment text
    char    add_date[24+1];              // Date record was added
    char    add_user[132+1];             // User who added record
    char    modify_date[24+1];           // Date record was last modified
    
    // Primary Key Field
    char    location[11+1];              // Location identifier (e.g., "A01-01-01")
    
    // Current Load Fields
    char    loadid[50+1];                // Current load ID at this location
    char    load_type[20+1];             // Type of load at location
    long    location_size;               // Size capacity of location
    
    // Status Fields
    char    location_status[15+1];       // Location status (AVAIL, OCCUPIED, LOCKED)
    char    locked_flag[8+1];            // Lock flag (YES/NO)
    char    locked_reason[30+1];         // Reason location is locked
    char    location_type[20+1];         // Location type (STOR, INTRAN, etc.)
    
    // Pending Fields (for move operations)
    char    pending_status[15+1];        // Pending status (PEND_STOR, PEND_RTRV)
    char    pending_loadid[50+1];        // Load ID pending at this location
    char    pending_location[11+1];      // Pending location (if different)
    
    // Physical Position Fields
    long    aisle;                       // Aisle number
    long    row_number;                  // Row number
    long    bay_number;                  // Bay number
    long    level_number;                // Level number
    long    deep_number;                 // Deep position (1, 2, etc.)
    
    // Double-Deep Fields
    bool    double_deep;                 // Is this a double-deep location?
    char    near_partner[11+1];          // Near partner location
    char    far_partner[11+1];           // Far partner location
    
    // Search/Selection Fields
    long    search_key_1;                // Search key 1 (for location selection)
    long    search_key_2;                // Search key 2 (for location selection)
    long    opt_zone;                    // Optimization zone
    
    // Exercise Fields
    bool    loc_exercised;               // Has location been exercised?
    double  store_time;                  // Last store time
    char    store_locn[8+1];            // Store location code
    
    // Equipment Fields
    char    sr_name[50+1];               // Stacker name that serves this location
    
    // Dedicated Fields
    char    dedicated_loadid[15+1];      // Dedicated load ID (if location reserved)
    char    dedicated_location[15+1];   // Dedicated location reference
    
    // Display Fields
    char    location_all[3+1];           // Location all flag (YES/NO)
    char    display_dir[1+1];            // Display direction
    
    // Statistics Fields
    long    store_count;                 // Number of times stored
    long    full_bin_count;              // Full bin count
    long    full_empty_bin_count;        // Full empty bin count
    
    // System Fields
    char    area[1+1];                   // System area
    
    // History Fields
    long    history_onoff;               // History on/off flag
    long    history_sequence_no;         // History sequence number
    
    // Internal Fields
    _RecordsetPtr    RsP;                // ADO Recordset pointer (internal use)
} LOCN;
```

---

## Primary Key

| Field(s) | Type | Description |
|----------|------|-------------|
| `location` | `char[12]` | Location identifier (e.g., "A01-01-01") |

**Location Format:** Typically `{Aisle}-{Bay}-{Level}` or `{Aisle}-{Bay}-{Level}-{Deep}`

---

## Generated Functions

### LOCN_select_LOCN_PR_KEY

**Signature:**
```cpp
long LOCN_select_LOCN_PR_KEY(LOCN *sel, GP_BOOL Update);
```

**Description:**
Selects a single LOCN record by primary key (`location`).

**SQL Generated:**
```sql
SELECT * FROM MHC_LOCATION WHERE location = '{location}'
```

**Usage Example:**
```cpp
LOCN locn;
LOCN_init(&locn);
cc_str.copy(locn.location, sizeof(locn.location), "A01-01-01");

if (LOCN_select_LOCN_PR_KEY(&locn, GP_FALSE) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Location %s: status=%s, loadid=%s", 
                  locn.location, locn.location_status, locn.loadid);
}
```

---

### LOCN_select_LOOP

**Signature:**
```cpp
long LOCN_select_LOOP(LOCN *sel, long *count, char *where, GP_BOOL Update, int top = 0);
```

**Description:**
Selects multiple LOCN records using a WHERE clause.

**Usage Example:**
```cpp
LOCN locn;
LOCN_init(&locn);
long count = 0;
char where[256];
sprintf(where, "location_status = 'AVAIL' AND aisle = 1 AND area = 'A'");

// Find available locations in aisle 1
while (LOCN_select_LOOP(&locn, &count, where, GP_FALSE, 0) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Available location: %s", locn.location);
}

count = -1;
LOCN_select_LOOP(&locn, &count, "", GP_FALSE, 0);
```

---

### LOCN_insert

**Signature:**
```cpp
long LOCN_insert(LOCN *sel, ...);
```

**Description:**
Inserts a new LOCN record. Used during system initialization to define all storage locations.

**Required Fields:**
- `location` (primary key)
- `location_status`
- `aisle`, `row_number`, `bay_number`, `level_number`
- `area`

---

### LOCN_update

**Signature:**
```cpp
long LOCN_update(LOCN *sel);
```

**Description:**
Updates an existing LOCN record. Commonly used to:
- Update location status (AVAIL → OCCUPIED)
- Set/clear pending status
- Lock/unlock locations
- Update load ID

**Usage Example:**
```cpp
SQL.start(SQL.READ_WRITE);

LOCN locn;
LOCN_init(&locn);
cc_str.copy(locn.location, sizeof(locn.location), "A01-01-01");

if (LOCN_select_LOCN_PR_KEY(&locn, GP_TRUE) == GP.GOOD) {
    // Mark location as occupied
    cc_str.copy(locn.location_status, sizeof(locn.location_status), "OCCUPIED");
    cc_str.copy(locn.loadid, sizeof(locn.loadid), "L00001");
    
    // Update audit
    double curDate;
    cs_dtm_current(&curDate);
    cs_dtm_fmt(locn.modify_date, sizeof(locn.modify_date), curDate, DTM_MASK);
    cc_str.copy(locn.modify_user, sizeof(locn.modify_user), gg.prgnam());
    
    if (LOCN_update(&locn) == GP.GOOD) {
        SQL.commit();
    } else {
        SQL.rollback();
    }
}
```

---

### LOCN_count

**Signature:**
```cpp
long LOCN_count(LOCN *sel, long* i_count, char *where);
```

**Description:**
Counts LOCN records matching a WHERE clause.

**Usage Example:**
```cpp
LOCN locn;
LOCN_init(&locn);
long availCount = 0;
char where[256];
sprintf(where, "location_status = 'AVAIL' AND aisle = 1");

if (LOCN_count(&locn, &availCount, where) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Available locations in aisle 1: %ld", availCount);
}
```

---

## Location Status Values

| Status | Description |
|--------|-------------|
| `AVAIL` | Available - location is empty and available for storage |
| `OCCUPIED` | Occupied - location has a load |
| `LOCKED` | Locked - location is locked out (maintenance, problem, etc.) |
| `RESERVED` | Reserved - location is reserved for specific load |

---

## Pending Status Values

| Status | Description |
|--------|-------------|
| `PEND_STOR` | Pending store - load will be stored here |
| `PEND_RTRV` | Pending retrieve - load will be retrieved from here |
| (empty) | No pending operation |

---

## Common Usage Patterns

### Pattern 1: Check Location Availability

```cpp
LOCN locn;
LOCN_init(&locn);
cc_str.copy(locn.location, sizeof(locn.location), "A01-01-01");

if (LOCN_select_LOCN_PR_KEY(&locn, GP_FALSE) == GP.GOOD) {
    if (cc_str.comp(locn.location_status, "AVAIL") == 0 && 
        cc_str.comp(locn.locked_flag, "NO") == 0) {
        // Location is available
        return GP.GOOD;
    } else {
        // Location not available
        return GP.BAD;
    }
} else {
    // Location not found
    return GP.UGLY;
}
```

### Pattern 2: Find Available Location

```cpp
LOCN locn;
LOCN_init(&locn);
long count = 0;
char where[256];
sprintf(where, "location_status = 'AVAIL' AND locked_flag = 'NO' AND aisle = %ld ORDER BY search_key_1", aisle);

while (LOCN_select_LOOP(&locn, &count, where, GP_FALSE, 0) == GP.GOOD) {
    // Found available location
    cc_str.copy(foundLocation, sizeof(foundLocation), locn.location);
    count = -1;
    LOCN_select_LOOP(&locn, &count, "", GP_FALSE, 0);
    return GP.GOOD;
}

count = -1;
LOCN_select_LOOP(&locn, &count, "", GP_FALSE, 0);
return GP.UGLY; // No available location found
```

### Pattern 3: Lock Location

```cpp
SQL.start(SQL.READ_WRITE);

LOCN locn;
LOCN_init(&locn);
cc_str.copy(locn.location, sizeof(locn.location), "A01-01-01");

if (LOCN_select_LOCN_PR_KEY(&locn, GP_TRUE) == GP.GOOD) {
    cc_str.copy(locn.locked_flag, sizeof(locn.locked_flag), "YES");
    cc_str.copy(locn.locked_reason, sizeof(locn.locked_reason), "MAINTENANCE");
    
    if (LOCN_update(&locn) == GP.GOOD) {
        SQL.commit();
    } else {
        SQL.rollback();
    }
}
```

---

## Related Tables

| Table | Relationship | Foreign Key |
|-------|--------------|-------------|
| `MHC_LOAD` | Reference | `MHC_LOAD.location = MHC_LOCATION.location` |
| `MHC_MOVS` | Reference | `MHC_MOVS.final_location = MHC_LOCATION.location` |
| `MHC_INVENTORY` | Reference | `MHC_INVENTORY.location = MHC_LOCATION.location` |

---

## Cross-References

| Topic | Document | Section |
|-------|----------|---------|
| Database Schema | [MHC_LOCATION Schema](../../04_Database_Reference/01_Core_Tables/MHC_LOCATION.md) | Table Definition |
| Location Selection | [DSUB Library](../dsub.md) | ds_get_locn functions |
| Location Counting | [DSUB Library](../dsub.md) | ds_locn_counts |
| Workflows | [Inbound Move](../../05_Workflows/01_Inbound_Move.md) | Location Selection |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-12-23 | Initial comprehensive documentation |

