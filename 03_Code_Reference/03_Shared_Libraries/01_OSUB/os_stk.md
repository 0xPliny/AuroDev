# os_stk - MHC_STK Table Operations

**Document Version:** 1.0  
**Last Updated:** 2024-12-23  
**Author:** CmL  
**Confidence Score:** 0.95

---

## Document Metadata

| Field | Value |
|-------|-------|
| **Source File** | `os_stk.cpp`, `os_stk.h` |
| **Generated From** | `MHC_STK` table definition in `database_tables.xml` |
| **Location** | `D:\ICIS\AuroDev\clogan\AuroDev\MSVC Programs\osub\` |
| **Table Name** | `MHC_STK` |
| **Primary Key** | `devicename`, `area` (composite) |
| **Generated By** | `p_ut_makdb` utility |
| **Status** | âœ… Generated - DO NOT MODIFY |

---

## Overview

The `MHC_STK` table stores **stacker crane (SR) database state** for each stacker in the system. This table tracks stacker status, position, errors, and operational state. The Auro system has 22 stackers (SR01-SR22).

**Critical Operations:**
- Stacker status tracking
- Position tracking (bay, level)
- Error state management
- Enroute move counting

**Relationship to Shared Memory:**
- Database state is synchronized with shared memory (`cc_stacker` class)
- Database provides persistence; shared memory provides real-time access

---

## Table Structure

```cpp
typedef struct stk
{
    // Primary Key Fields
    char    devicename[30+1];            // Stacker name (e.g., "SR01")
    char    area[1+1];                   // System area
    
    // Index and Version
    long    s_idx;                       // Stacker index
    long    version;                     // Version (for shared memory compatibility)
    
    // Communication Fields
    long    comm;                        // Communication status
    long    comm_bit;                    // Communication bit
    char    comm_mon_mv[32+1];          // Communication monitor for moves
    
    // Status Fields
    long    data;                        // Data status
    long    hard;                        // Hardware status
    long    soft;                        // Software status
    long    enabled;                     // Enabled flag
    long    can_go;                      // Can go flag
    
    // Position Fields
    long    level_number;                // Current level
    long    bay_no;                      // Current bay number
    long    level_no;                    // Current level number
    long    sr_level;                    // Stacker level
    char    last_atlocation[132+1];     // Last at location
    
    // Function Fields
    long    func;                        // Current function
    long    func_ctrl;                   // Function control
    long    func_step;                   // Current function step
    long    last_func;                   // Last function
    long    home;                        // Home position flag
    long    mode;                        // Operating mode
    
    // Fork Fields (for multi-fork stackers)
    long    forks;                       // Number of forks
    bool    fork_cycle_comp;             // Fork cycle complete
    long    forkloadwidth;               // Fork load width
    long    forkloadlength;              // Fork load length
    long    fork_pallet_type;            // Fork pallet type
    long    fork_step_curr;              // Fork current step
    long    fork_step_max;               // Fork max steps
    long    fork_need_next_step;         // Fork needs next step
    long    fork_need_same_step;         // Fork needs same step repeated
    long    fork_state;                  // Fork state
    
    // Load Fields
    char    loadid[24+1];                // Current load ID
    char    location_from[20+1];        // From location
    char    location_to[20+1];          // To location
    long    loaded;                      // Loaded flag
    
    // Error Fields
    long    error_no;                    // Error number
    char    error_xlat[255+1];          // Error translation
    long    error_status;                // Error status
    long    error_sub_code;              // Error sub-code
    long    state_error;                 // State error
    char    error_description[200+1];   // Error description
    long    error_return_dsc;            // Error return descriptor
    long    error_return_home_dsc;       // Error return home descriptor
    
    // Enroute Fields
    long    enroute;                     // Current enroute count
    long    enroute_total;               // Total enroute
    long    max_enroute;                 // Maximum enroute allowed
    
    // Statistics Fields
    long    empty_count;                 // Empty location count
    long    cnt_retrieves;               // Retrieve count
    
    // Run State Fields
    long    last_run_mode;               // Last run mode
    long    last_run_status;             // Last run status
    long    laststate;                   // Last state
    long    request;                      // Request flag
    long    schedule;                    // Schedule flag
    long    line_stat;                   // Line status
    long    cleanout;                    // Cleanout flag
    
    // Message Fields
    long    last_132response;            // Last 132 response
    long    last_132reporttype;          // Last 132 report type
    long    last_132type1;               // Last 132 type 1
    char    msg_response_xlat[132+1];    // Message response translation
    long    msg_response_code;           // Message response code
    char    msg_function[132+1];         // Message function
    
    // Identification Fields
    long    aisle;                       // Aisle number
    char    long_name[100+1];            // Long name
    char    type_of[100+1];             // Type description
    char    program[32+1];               // Program name
    
    // Time Fields
    char    start_time_str[24+1];       // Start time string
    char    flush_time[24+1];           // Flush time
    
    // Audit Fields
    char    add_date[24+1];              // Date record was added
    char    add_user[132+1];            // User who added record
    char    modify_date[24+1];          // Date record was last modified
    char    modify_user[132+1];         // User who last modified record
    
    // Internal Fields
    char    STK_dum[1];                  // Dummy field (alignment)
    _RecordsetPtr    RsP;                // ADO Recordset pointer (internal use)
} STK;
```

---

## Primary Key

| Field(s) | Type | Description |
|----------|------|-------------|
| `devicename` | `char[31]` | Stacker device name (e.g., "SR01") |
| `area` | `char[2]` | System area |

---

## Generated Functions

### STK_select_STK_PR_KEY

**Signature:**
```cpp
long STK_select_STK_PR_KEY(STK *sel, GP_BOOL Update);
```

**Description:**
Selects a single STK record by primary key (`devicename` and `area`).

**SQL Generated:**
```sql
SELECT * FROM MHC_STK WHERE devicename = '{devicename}' AND area = '{area}'
```

**Usage Example:**
```cpp
STK stk;
STK_init(&stk);
cc_str.copy(stk.devicename, sizeof(stk.devicename), "SR01");
cc_str.copy(stk.area, sizeof(stk.area), "A");

if (STK_select_STK_PR_KEY(&stk, GP_FALSE) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Stacker %s: func=%ld, comm=%ld, error=%ld", 
                  stk.devicename, stk.func, stk.comm, stk.error_no);
}
```

---

### STK_select_LOOP

**Signature:**
```cpp
long STK_select_LOOP(STK *sel, long *count, char *where, GP_BOOL Update, int top = 0);
```

**Description:**
Selects multiple STK records using a WHERE clause. Commonly used to iterate through all stackers.

**Usage Example:**
```cpp
STK stk;
STK_init(&stk);
long count = 0;
char where[256];
sprintf(where, "area = 'A' AND enabled = 1 ORDER BY devicename");

// Get all enabled stackers
while (STK_select_LOOP(&stk, &count, where, GP_FALSE, 0) == GP.GOOD) {
    cs_log_printf(FILELINE, 3, "Stacker %s: enroute=%ld/%ld", 
                  stk.devicename, stk.enroute, stk.max_enroute);
}

count = -1;
STK_select_LOOP(&stk, &count, "", GP_FALSE, 0);
```

---

### STK_update

**Signature:**
```cpp
long STK_update(STK *sel);
```

**Description:**
Updates an existing STK record. Used to synchronize database state with shared memory.

**Usage Example:**
```cpp
SQL.start(SQL.READ_WRITE);

STK stk;
STK_init(&stk);
cc_str.copy(stk.devicename, sizeof(stk.devicename), "SR01");
cc_str.copy(stk.area, sizeof(stk.area), "A");

if (STK_select_STK_PR_KEY(&stk, GP_TRUE) == GP.GOOD) {
    // Update from shared memory
    cc_stacker* SR = cc_stacker_ctrl.Find_Stk("SR01");
    if (SR) {
        stk.func = SR->func();
        stk.comm = SR->comm();
        stk.bay_no = SR->bay();
        stk.level_no = SR->level();
        stk.error_no = SR->error_code();
    }
    
    // Update audit
    double curDate;
    cs_dtm_current(&curDate);
    cs_dtm_fmt(stk.modify_date, sizeof(stk.modify_date), curDate, DTM_MASK);
    cc_str.copy(stk.modify_user, sizeof(stk.modify_user), gg.prgnam());
    
    if (STK_update(&stk) == GP.GOOD) {
        SQL.commit();
    } else {
        SQL.rollback();
    }
}
```

---

## Common Usage Patterns

### Pattern 1: Get Stacker Status

```cpp
STK stk;
STK_init(&stk);
cc_str.copy(stk.devicename, sizeof(stk.devicename), "SR01");
cc_str.copy(stk.area, sizeof(stk.area), "A");

if (STK_select_STK_PR_KEY(&stk, GP_FALSE) == GP.GOOD) {
    if (stk.comm == GP.COM.ONLI) {
        cs_log_printf(FILELINE, 3, "Stacker %s is online", stk.devicename);
    } else {
        cs_log_printf(FILELINE, 0, "Stacker %s is offline", stk.devicename);
    }
    
    if (stk.error_no != 0) {
        cs_log_printf(FILELINE, 0, "Stacker %s has error: %s", 
                      stk.devicename, stk.error_xlat);
    }
}
```

### Pattern 2: Check Enroute Capacity

```cpp
STK stk;
STK_init(&stk);
cc_str.copy(stk.devicename, sizeof(stk.devicename), "SR01");
cc_str.copy(stk.area, sizeof(stk.area), "A");

if (STK_select_STK_PR_KEY(&stk, GP_FALSE) == GP.GOOD) {
    if (stk.enroute < stk.max_enroute) {
        // Stacker can accept more moves
        return GP.GOOD;
    } else {
        // Stacker at capacity
        return GP.BAD;
    }
}
```

---

## Related Tables

| Table | Relationship | Foreign Key |
|-------|--------------|-------------|
| `MHC_MOVS` | Reference | `MHC_MOVS.vehicle_name = MHC_STK.devicename` |
| Shared Memory | Synchronized | `cc_stacker` class mirrors STK data |

---

## Cross-References

| Topic | Document | Section |
|-------|----------|---------|
| Stacker Control | [CCSUB Library](../ccsub.md) | cc_stacker class |
| Stacker Dispatcher | [p_ar_stkdp](../01_Background_Processes/p_ar_stkdp.md) | Uses STK |
| Stacker Communications | [p_cc_stkcmx](../01_Background_Processes/p_cc_stkcmx.md) | Updates STK |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-12-23 | Initial comprehensive documentation |

